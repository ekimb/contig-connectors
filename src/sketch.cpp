//hash into uint64 (from minimap2: sketch.c)

#include "sketch.hpp"
#include <math.h>
#include <iostream>

inline uint64_t hash64(uint64_t key, uint64_t mask)
{
    key = (~key + (key << 21)) & mask; // key = (key << 21) - key - 1;
    key = key ^ key >> 24;
    key = ((key + (key << 3)) + (key << 8)) & mask; // key * 265
    key = key ^ key >> 14;
    key = ((key + (key << 2)) + (key << 4)) & mask; // key * 21
    key = key ^ key >> 28;
    key = (key + (key << 31)) & mask;
    return key;
}

//seq_nt4 table (from minimap2: sketch.c)

static unsigned char seq_nt4_table[256] = {
        0, 1, 2, 3,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,
        4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,
        4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,
        4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,
        4, 0, 4, 1,  4, 4, 4, 2,  4, 4, 4, 4,  4, 4, 4, 4,
        4, 4, 4, 4,  3, 3, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,
        4, 0, 4, 1,  4, 4, 4, 2,  4, 4, 4, 4,  4, 4, 4, 4,
        4, 4, 4, 4,  3, 3, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,
        4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,
        4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,
        4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,
        4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,
        4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,
        4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,
        4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,
        4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4
};

static inline void minimizers(int k, std::string &seq, float density, std::vector<uint64_t> &hashes, std::vector<unsigned int> &coords) {
	int i, l;
    float hash_bound = density * float(pow(4, k)); 
	uint64_t x[2], mask = (1ULL<<k*2) - 1, shift = (k - 1) * 2;
	for (i = l = 0, x[0] = x[1] = 0; i < seq.length(); ++i) {
		int absent, c = seq_nt4_table[(uint8_t)seq[i]];
		if (c < 4) { // not an "N" base
			x[0] = (x[0] << 2 | c) & mask;                  // forward strand
			x[1] = x[1] >> 2 | (uint64_t)(3 - c) << shift;  // reverse strand
			if (++l >= k) { // we find a k-mer
				uint64_t y = x[0] < x[1]? x[0] : x[1];
				uint64_t h = hash64(y, mask);
				if (float(h) <= hash_bound) {
                    hashes.push_back(h);
                    coords.push_back(i - k + 1);
                }
			}
		} else l = 0, x[0] = x[1] = 0; // if there is an "N", restart
	}
}

Sketch get_sketch(int k, std::string &seq, float density, unsigned int ref_id, bool is_query) {
    std::vector<Minimizer> v;
    std::vector<Minimizer> v_rev;
    std::vector<unsigned int> cont_ids = std::vector<unsigned int>();
    Sketch sk;
    if (seq.length() < k) {return sk;}
    std::transform(seq.begin(), seq.end(), seq.begin(), ::toupper);
    std::vector<uint64_t> hashes;
    std::vector<unsigned int> coords;
    minimizers(k, seq, density, hashes, coords);
    unsigned int sk_len = hashes.size();
    for (int i = 0; i < sk_len; i++) {
        Minimizer m;
        m.hash = hashes[i]; m.pos = coords[i];
        v.push_back(m);
        if (is_query) {
            Minimizer m_rev;
            m_rev.hash = hashes[sk_len - i - 1]; m_rev.pos = seq.length() - coords[sk_len - i - 1] - k;
            v_rev.push_back(m_rev);
        }
    }
    Sketch skf = {v, v_rev, ref_id, cont_ids};
    return skf;
}



